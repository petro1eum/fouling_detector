<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cross-Flow Heat Exchanger Fouling Detection</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        :root {
            --primary-color: #4361ee;
            --primary-light: #4895ef;
            --primary-dark: #3f37c9;
            --success-color: #4CC9F0;
            --warning-color: #F72585;
            --text-color: #2b2d42;
            --text-light: #6c757d;
            --background-color: #f8f9fa;
            --card-bg: #ffffff;
            --border-color: #e9ecef;
            --equation-bg: #f1f3f5;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --border-radius: 10px;
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
            color: var(--text-color);
            background-color: var(--background-color);
            font-size: 15px;
        }

        h1, h2, h3, h4 {
            color: var(--text-color);
            font-weight: 600;
            line-height: 1.3;
            margin-bottom: 0.8em;
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 700;
            text-align: center;
            margin: 1.5rem 0;
            background: linear-gradient(90deg, var(--primary-dark), var(--primary-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            font-size: 1.6rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 1.3rem;
            font-weight: 600;
        }

        h4 {
            font-size: 1.1rem;
            margin-top: 1.5rem;
        }

        p {
            margin-bottom: 1rem;
            color: var(--text-light);
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            justify-content: space-between;
            margin-top: 25px;
        }

        .model-section, .parameters-section, .detection-section {
            flex: 1;
            min-width: 300px;
            border-radius: var(--border-radius);
            padding: 25px;
            background-color: var(--card-bg);
            box-shadow: var(--shadow-md);
            transition: var(--transition);
            border: 1px solid var(--border-color);
        }

        .model-section:hover, .parameters-section:hover, .detection-section:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .equation {
            background-color: var(--equation-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Times New Roman', Times, serif;
            text-align: center;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }

        .parameter-plot, .fouling-plot {
            width: 100%;
            height: 250px;
            margin: 20px 0;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .fouling-plot {
            height: 150px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 500;
            font-size: 1rem;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
            min-width: 120px;
        }

        button:hover {
            background-color: var(--primary-dark);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }

        #startButton {
            background-color: var(--success-color);
        }

        #startButton:hover {
            background-color: #3DB5D8;
        }

        #resetButton {
            background-color: var(--text-light);
        }

        #resetButton:hover {
            background-color: #5a6268;
        }

        .heat-exchanger-diagram {
            width: 100%;
            height: 200px;
            margin: 20px 0;
            border-radius: var(--border-radius);
            background-color: var(--card-bg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .slider-container {
            display: flex;
            align-items: center;
            margin: 15px 0;
            background-color: var(--equation-bg);
            padding: 12px 15px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
        }

        .slider-container label {
            flex: 0 0 120px;
            font-weight: 500;
            color: var(--text-color);
        }

        input[type="range"] {
            flex: 1;
            height: 5px;
            -webkit-appearance: none;
            appearance: none;
            background: #d1d5db;
            border-radius: 5px;
            outline: none;
            margin: 0 15px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            transition: var(--transition);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-dark);
            transform: scale(1.2);
        }

        .slider-container span {
            flex: 0 0 60px;
            font-weight: 500;
            text-align: right;
            color: var(--primary-color);
        }

        canvas {
            background-color: var(--card-bg);
            border-radius: calc(var(--border-radius) - 1px);
        }

        .tab {
            margin-left: 20px;
        }

        .code-explanation {
            font-size: 0.9rem;
            color: var(--text-light);
            font-style: italic;
        }

        .matrix-container {
            max-width: 100%;
            overflow-x: auto;
            margin: 15px 0;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            padding: 10px;
        }

        #detectionResult {
            background-color: var(--equation-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-top: 20px;
            border-left: 4px solid var(--primary-color);
            transition: var(--transition);
        }

        #detectionResult p {
            margin-bottom: 10px;
            color: var(--text-color);
        }

        #detectionResult p:last-child {
            margin-bottom: 0;
        }

        #detectionResult strong {
            color: var(--warning-color);
            font-weight: 600;
        }

        ul {
            margin-left: 20px;
            margin-bottom: 15px;
            color: var(--text-light);
        }

        li {
            margin-bottom: 5px;
        }

        /* For smaller screens */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            
            .container {
                flex-direction: column;
            }
            
            .model-section, .parameters-section, .detection-section {
                width: 100%;
                margin-bottom: 20px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            h2 {
                font-size: 1.4rem;
            }
            
            h3 {
                font-size: 1.2rem;
            }
        }

        /* Collapsible sections for formulas */
        details {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        summary {
            padding: 12px 15px;
            cursor: pointer;
            font-weight: 500;
            background-color: var(--equation-bg);
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            transition: var(--transition);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        summary:hover {
            background-color: rgba(67, 97, 238, 0.1);
        }

        summary::after {
            content: "⊕";
            font-size: 1.2rem;
        }

        details[open] summary::after {
            content: "⊖";
        }

        details .content {
            padding: 15px;
        }

        /* Improved canvas container for graphs */
        .graphs-container {
            margin: 30px 0;
            background: var(--card-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
        }

        .visualization-section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .visualization-section:last-child {
            border-bottom: none;
        }

        .visualization-section h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-weight: 600;
        }

        /* Better canvas appearance */
        canvas {
            width: 100%;
            height: auto;
            box-shadow: var(--shadow-sm);
            background: linear-gradient(to bottom, #ffffff, #f8f9fa);
        }
    </style>
</head>
<body>
    <h1>Fouling Detection in Cross-Flow Heat Exchanger Based on Physical Modeling</h1>
    
    <p>This interactive module demonstrates the method described in the paper by O. Gudmundsson, O.P. Palsson, H. Palsson, and S. Lalot for detecting fouling in cross-flow heat exchangers using physical modeling.</p>
    
    <h2>Model Overview</h2>
    <p>The model is based on dividing the heat exchanger into equal sections on both the hot and cold sides. The states of the model are the temperatures in these sections, and the model is written in state space form.</p>
    
    <p class="note" style="text-align: center; font-weight: 500; color: var(--primary-color); margin-bottom: 20px;">
        All visualizations are displayed below
    </p>
    
    <div class="graphs-container">
        <div class="visualization-section">
            <h4>Heat Exchanger Diagram (4×4 Grid)</h4>
            <div style="position: relative; height: 198px; width: 100%;">
                <canvas id="heatExchangerCanvas" width="900" height="198"></canvas>
            </div>
        </div>
        
        <div class="visualization-section">
            <h4>Fouling Factor Evolution</h4>
            <div style="position: relative; height: 148px; width: 100%;">
                <canvas id="foulingChart"></canvas>
            </div>
        </div>
        
        <div class="visualization-section">
            <h4>Parameter Evolution Visualization</h4>
            <div style="position: relative; height: 248px; width: 100%;">
                <canvas id="parameterChart"></canvas>
            </div>
        </div>
        
        <div class="visualization-section">
            <h4>Fouling Detection Visualization (CuSum)</h4>
            <div style="position: relative; height: 248px; width: 100%;">
                <canvas id="detectionChart"></canvas>
            </div>
        </div>
        
        <div class="controls">
            <button id="startButton">Start Simulation</button>
            <button id="resetButton">Reset</button>
        </div>
        
        <div class="slider-container">
            <label for="foulingRate">Fouling Rate:</label>
            <input type="range" id="foulingRate" min="0" max="100" value="20">
            <span id="foulingRateValue">0.0001</span>
        </div>
        
        <div class="slider-container">
            <label for="noiseLevel">Noise Level:</label>
            <input type="range" id="noiseLevel" min="0" max="100" value="10">
            <span id="noiseLevelValue">0.5%</span>
        </div>
        
        <div id="detectionResult">
            <p>Status: No fouling detected</p>
            <p>Time to detection: N/A</p>
        </div>
    </div>
    
    <div class="container">
        <div class="model-section">
            <h3>Physical Model</h3>
            
            <details>
                <summary>Energy balance equation</summary>
                <div class="content">
                    <p>The differential energy balance equation for each section is:</p>
                    <div class="equation">
                        MC<sub>ij</sub>dT<sub>ij</sub>/dt = ṁ(t)c[T<sub>i-n,j-m</sub>(t) - T<sub>ij</sub>(t)] ± AU<sub>ij</sub>(t)F∆T<sub>ij</sub>(t)
                    </div>
                    
                    <p>Where:</p>
                    <ul>
                        <li>i) is the energy change in section ij at time t</li>
                        <li>ii) is the energy flow in the fluid in section ij</li>
                        <li>iii) is the energy transferred from or to section ij</li>
                        <li>n = 1, m = 0 for cold side, n = 0, m = 1 for hot side</li>
                        <li>Positive sign for cold side, negative for hot side</li>
                    </ul>
                </div>
            </details>
            
            <details>
                <summary>Temperature difference</summary>
                <div class="content">
                    <p>The arithmetic mean temperature difference:</p>
                    <div class="equation">
                        ∆T<sub>ij</sub>(t) = [T<sub>h,ij-1</sub>(t)+T<sub>h,ij</sub>(t)]/2 - [T<sub>c,i-1,j</sub>(t)+T<sub>c,ij</sub>(t)]/2
                    </div>
                </div>
            </details>
            
            <details>
                <summary>Correction factor</summary>
                <div class="content">
                    <p>Correction factor F is calculated using the NTU method:</p>
                    <div class="equation">
                        F = ∆T(minimum fluid)/(NTU·∆T<sub>LMTD</sub>)
                    </div>
                </div>
            </details>

            <details>
                <summary>State space representation</summary>
                <div class="content">
                    <p>The state space representation with parameters:</p>
                    <div class="equation">
                        d/dt T = A(ṁ, θ, F)T + B(ṁ, θ, F)T<sub>in</sub>
                    </div>
                    
                    <p>For a 4×4 grid model, the state vector and matrices are:</p>
                    <div class="matrix-container">
                        <div style="text-align: center; padding: 20px; background-color: #f8f9fa; border: 1px dashed #ccc;">
                            [Matrix representation for 4×4 grid model with 16 states]
                        </div>
                    </div>
                </div>
            </details>
        </div>
        
        <div class="parameters-section">
            <h3>Parameter Estimation</h3>
            
            <details>
                <summary>Model parameters</summary>
                <div class="content">
                    <p>The model parameters are defined as:</p>
                    <div class="equation">
                        α(t) = FA<sub>h</sub>U<sub>ij</sub>(t)/ṁ<sub>h</sub>(t)c<sub>h</sub>
                    </div>
                    <div class="equation">
                        β(t) = FA<sub>c</sub>U<sub>ij</sub>(t)/ṁ<sub>c</sub>(t)c<sub>c</sub>
                    </div>
                    <div class="equation">
                        τ<sub>h</sub>(t) = M<sub>h</sub>/ṁ<sub>h</sub>(t)
                    </div>
                    <div class="equation">
                        τ<sub>c</sub>(t) = M<sub>c</sub>/ṁ<sub>c</sub>(t)
                    </div>
                </div>
            </details>
            
            <details>
                <summary>Heat transfer coefficient</summary>
                <div class="content">
                    <p>Heat transfer coefficient is modeled empirically as:</p>
                    <div class="equation">
                        h(t) = C′ṁ<sup>γ</sup>(t)
                    </div>
                    
                    <p>Overall heat transfer coefficient:</p>
                    <div class="equation">
                        U(t) = h<sub>h</sub>(t)h<sub>c</sub>(t)/(h<sub>h</sub>(t)+h<sub>c</sub>(t)) = C′(ṁ<sub>h</sub>(t)ṁ<sub>c</sub>(t))<sup>γ</sup>/(ṁ<sub>h</sub><sup>γ</sup>(t)+ṁ<sub>c</sub><sup>γ</sup>(t))
                    </div>
                </div>
            </details>
            
            <details>
                <summary>Normalized parameters</summary>
                <div class="content">
                    <p>Normalized parameters using reference mass flow ṁ<sub>ref</sub>:</p>
                    <div class="equation">
                        α(t) = α<sub>*</sub>·ṁ<sub>h,ref</sub>/ṁ<sub>h</sub>(t)·U(t)/U<sub>ref</sub>
                    </div>
                    <div class="equation">
                        β(t) = β<sub>*</sub>·ṁ<sub>c,ref</sub>/ṁ<sub>c</sub>(t)·U(t)/U<sub>ref</sub>
                    </div>
                    <div class="equation">
                        U<sub>ref</sub> = C′(ṁ<sub>h,ref</sub>ṁ<sub>c,ref</sub>)<sup>γ</sup>/(ṁ<sub>h,ref</sub><sup>γ</sup>+ṁ<sub>c,ref</sub><sup>γ</sup>)
                    </div>
                </div>
            </details>
            
            <details>
                <summary>Parameter estimation method</summary>
                <div class="content">
                    <p>The parameters are estimated using a least squares method with the help of a Kalman filter to estimate the states:</p>
                    <div class="equation">
                        V(θ) = Σ<sub>t=1</sub><sup>N</sup> ξ<sup>T</sup>(t)ξ(t)
                    </div>
                    
                    <p>Fouling factor directly affects U:</p>
                    <div class="equation">
                        U = 1/(1/(A<sub>c</sub>h<sub>c</sub>) + 1/(A<sub>h</sub>h<sub>h</sub>) + R<sub>f</sub>)
                    </div>
                </div>
            </details>
        </div>
        
        <div class="detection-section">
            <h3>Fouling Detection</h3>
            <p>When fouling accumulates, the heat transfer coefficient U decreases. Since α and β are proportional to U, they also decrease.</p>
            
            <details>
                <summary>Cumulative Sum (CuSum) Method</summary>
                <div class="content">
                    <p>The Cumulative Sum (CuSum) control chart is used to detect small shifts in the mean of these parameters:</p>
                    <div class="equation">
                        Cus(i) = max{0, (μ<sub>0</sub> - x̄<sub>i</sub>) - K + Cus(i-1)}
                    </div>
                    <p>where:</p>
                    <ul>
                        <li>μ<sub>0</sub> is the reference value (no fouling)</li>
                        <li>x̄<sub>i</sub> is the moving average over 40 samples</li>
                        <li>K is the reference value (set to 2σ<sub>θ,clean</sub>)</li>
                        <li>If Cus(i) > H*, then fouling is detected (H* = 3σ<sub>θ,clean</sub>)</li>
                    </ul>
                </div>
            </details>
            
            <details>
                <summary>Detection Thresholds</summary>
                <div class="content">
                    <h4>Detection Threshold:</h4>
                    <p>Typical fouling factor range in water heat exchangers: [0.0001, 0.0007] m²·°C/W</p>
                    <p>Detection usually happens at Rf ≈ 0.0001 (lower limit of design factor)</p>
                </div>
            </details>
        </div>
    </div>
    
    <h2>Implementation Details</h2>
    <p>The simulation implements the model from the paper with 4 sections on each side of the heat exchanger (4x4 grid). The parameters are estimated from simulated data and monitored for fouling detection using the CuSum method as specified in the paper.</p>
    
    <ul>
        <li>Heat exchanger dimensions: 0.5m × 0.5m × 0.002m</li>
        <li>Water on both sides (c<sub>h</sub> = c<sub>c</sub> = 4200 J/kg·°C, ρ = 998 kg/m³)</li>
        <li>Reference mass flow: ṁ<sub>h,ref</sub> = ṁ<sub>c,ref</sub> = 1 kg/s</li>
        <li>Temperature ranges: Hot [54.7°C, 99.4°C], Cold [13.3°C, 27.6°C]</li>
        <li>Maximum fouling factor: 0.0004 m²·°C/W</li>
    </ul>
    
    <script>
        // Model parameters based on the paper (Tables 1 & 2, page 452)
        const params = {
            // Parameter values from Table 1 & 2:
            // "Estimated values: α = 0.112, β = 0.126, τh = 0.25, τc = 0.25, γ = 0.8"
            alpha: 0.112,         // Initial alpha parameter - Table 2
            beta: 0.126,          // Initial beta parameter - Table 2
            tau_h: 0.25,          // Tau_h parameter (fixed) - Table 1
            tau_c: 0.25,          // Tau_c parameter (fixed) - Table 1
            gamma: 0.8,           // Gamma parameter (exponent of Reynolds number) - Table 1, "literature recommends γ = 0.8"
            
            // From page 452: "The overall heat transfer coefficient can be calculated from the relation
            // mhch(Th,in - Th,out) = AU∆TLMTD to be U = 3.62 kW/m²°C"
            U_ref: 3.62,          // Reference overall heat transfer coefficient (kW/m²°C)
            
            foulingRate: 0.0001,  // Rate of fouling increase
            noiseLevel: 0.005,    // Noise level for parameters
            
            // From page 451: "The parameters K and H were chosen to be 2σθ,clean and 3σθ,clean respectively"
            cusum_K: 0.001,       // CuSum reference value (2*σ_θ,clean)
            cusum_H: 0.015,       // CuSum threshold (3*σ_θ,clean)
            
            detectionTime: 0,     // Time to detection
            running: false,       // Simulation state
            time: 0,              // Current simulation time
            foulingStart: 100,    // Time step when fouling starts
            
            // From page 451: "to save computing time the fouling factor was allowed to be maximum Rf = 0.0004"
            maxFouling: 0.0004,   // Maximum fouling factor (m²°C/W)
            
            // From page 452: "The average massflows was mh = mc = 1 [kg/s]"
            mh_ref: 1.0,          // Reference mass flow for hot side (kg/s)
            mc_ref: 1.0,          // Reference mass flow for cold side (kg/s)
            
            // From page 452: "The dimensions of the simulated heat exchanger where 0.5 m wide and height"
            Ah: 0.5,              // Heat transfer area for hot side (m²)
            Ac: 0.5,              // Heat transfer area for cold side (m²)
            
            // From page 452: "It was assumed that the specific heat was constant, ch = cc = 4200 [J/kg°C]"
            ch: 4200,             // Specific heat for hot fluid (J/kg°C)
            cc: 4200,             // Specific heat for cold fluid (J/kg°C)
            
            // From page 447: "For the cross-flow heat exchanger (Cengel and Turner, 2005) recommend 
            // to use the representation of ∆T(ij) for the counter-flow heat exchanger with a correction factor F."
            // From page 452: "The correction factor was estimated from Eq. (6) to be F = 0.95"
            F: 0.95,              // Correction factor
            
            // From page 452: "the density of the fluids where ρ = 998 [kg/m³]"
            density: 998          // Fluid density (kg/m³)
        };
        // Data structure to store simulation results for analysis and visualization
        let simulationData = {
            timePoints: [],        // Time steps
            alphaValues: [],       // Alpha parameter values over time
            betaValues: [],        // Beta parameter values over time
            foulingValues: [],     // Fouling factor (Rf) values over time
            uValues: [],           // Overall heat transfer coefficient values over time
            cusumAlpha: [],        // Cumulative sum for Alpha parameter
            cusumBeta: [],         // Cumulative sum for Beta parameter
            mhValues: [],          // Hot side mass flow values 
            mcValues: [],          // Cold side mass flow values
            fValues: []            // Correction factor F values
        };
        
        // Initialize the simulation
        function initSimulation() {
            params.time = 0;
            simulationData = {
                timePoints: [0],
                alphaValues: [params.alpha],
                betaValues: [params.beta],
                foulingValues: [0],
                uValues: [params.U_ref],
                cusumAlpha: [0],
                cusumBeta: [0],
                mhValues: [1.0],
                mcValues: [1.0],
                fValues: [params.F]
            };
            
            params.detectionTime = 0;
            document.getElementById('detectionResult').innerHTML = '<p>Status: No fouling detected</p><p>Time to detection: N/A</p>';
            
            // Уничтожаем существующие графики при сбросе
            if (foulingChart) {
                foulingChart.destroy();
                foulingChart = null;
            }
            
            if (parameterChart) {
                parameterChart.destroy();
                parameterChart = null;
            }
            
            if (detectionChart) {
                detectionChart.destroy();
                detectionChart = null;
            }
            
            drawHeatExchanger();
            drawFoulingPlot();
            drawParameterPlot();
            drawDetectionPlot();
        }
        
        // Calculation of NTU and correction factor F according to equations (5-8)
        function calculateF(mh, mc, U) {
            // From page 448: Determine minimum fluid mass flow
            const Ch = mh * params.ch;  // Heat capacity rate for hot fluid
            const Cc = mc * params.cc;  // Heat capacity rate for cold fluid
            const Cmin = Math.min(Ch, Cc);
            const Cmax = Math.max(Ch, Cc);
            const Cr = Cmin / Cmax;     // Heat capacity ratio
            
            // Calculate NTU according to equation (5) on page 448:
            // "NTU = UA/Cmin"
            const A = (params.Ah + params.Ac) / 2;  // Average heat transfer area
            const NTU = U * A / Cmin;
            
            // Calculate effectiveness using equation (8) on page 448 for cross-flow with both fluids unmixed:
            // "ε₂ = 1 - exp[(exp(-NTU^0.78*Cmin/Cmax)-1)/(Cmin/Cmax*NTU^-0.22)]"
            const effectiveness = 1 - Math.exp((Math.exp(-Math.pow(NTU, 0.78) * Cr) - 1) / (Cr * Math.pow(NTU, -0.22)));
            
            // Calculate maximum possible heat transfer
            // q_max = Cmin * (Th,in - Tc,in)
            // We'll use average temperatures from the paper
            const Th_in = 75.0;  // Average hot inlet temperature from the paper page 452
            const Tc_in = 20.2;  // Average cold inlet temperature from the paper page 452
            const q_max = Cmin * (Th_in - Tc_in);
            
            // Calculate actual heat transfer using effectiveness
            const q_actual = effectiveness * q_max;
            
            // Calculate LMTD (Log Mean Temperature Difference)
            // We use arithmetic mean as suggested in the paper page 447:
            // "In (Jonsson et al., 1992) where counter flow heat exchanger where studied
            // it is suggested to use arithmetic mean temperature difference since the log mean
            // temperature difference will introduce extra nonlinearities in the model."
            const Th_out = 65.3;  // From paper page 452
            const Tc_out = 29.9;  // From paper page 452
            const dT_1 = Th_in - Tc_out;
            const dT_2 = Th_out - Tc_in;
            const LMTD = (dT_1 + dT_2) / 2;  // Arithmetic mean as per equation (2) and page 447
            
            // Calculate correction factor F using equation (6) on page 448:
            // "F = ΔT(minimum fluid)/(NTU·ΔLMTD)"
            const dT_min = q_actual / Cmin;
            const F = dT_min / (NTU * LMTD);
            
            return {F, NTU, effectiveness};
        }
        
        // Calculate overall heat transfer coefficient based on mass flows and fouling
        function calculateU(mh, mc, Rf) {
            // Calculate initial U without fouling to determine F
            // Using iterative approach since F depends on U and U depends on F
            
            // Initial guess for U based on heat transfer coefficients
            // Calculate heat transfer coefficients based on equation (18) from the paper (page 449):
            // "h(t) = C'ṁ^γ(t)"
            // Where γ = 0.8 for turbulent flow as stated in the paper page 452:
            // "The literature recommends to use y = 0.8 for a turbulent flow (Cengel and Turner, 2005)."
            const hh = Math.pow(mh, params.gamma); // Using C' = 1 for simplicity
            const hc = Math.pow(mc, params.gamma);
            
            // Initial U calculation without fouling or correction factor
            let U = 1 / (1/(params.Ah * hh) + 1/(params.Ac * hc));
            
            // One-pass correction with F calculation
            // In a full implementation, this would be iterated until convergence
            // Note: In the paper, a pre-calculated F = 0.95 is used based on steady-state conditions
            const {F} = calculateF(mh, mc, U);
            
            // Final U calculation with fouling and correction factor F
            // Using equation (31) from page 450:
            // "U = 1/(1/(Ac*hc) + 1/(Ah*hh) + Rf)"
            // Applying correction factor F to adjust heat transfer coefficients
            U = 1 / (1/(params.Ah * hh * F) + 1/(params.Ac * hc * F) + Rf);
            
            return U;
        }
        
        // Run simulation step
        function simulationStep() {
            if (!params.running) return;
            
            // Increment time
            params.time++;
            simulationData.timePoints.push(params.time);
            
            // Calculate fouling factor based on Figure 2 of the paper (page 451)
            // "In (Bohnet, 2005) it is shown that fouling grows with increased rate during the fouling period."
            // The paper simulates fouling starting after 25% of the dataset (page 451):
            // "The data used in this study were simulated without fouling for the first 25% of the data points
            // and then fouling was introduced."
            let foulingFactor = 0;
            if (params.time > params.foulingStart) {
                // Use exponential growth for fouling as shown in Figure 2 of the paper
                // This models the accelerating growth of fouling described in Bohnet, 2005
                const timeSinceFouling = (params.time - params.foulingStart) / 300;
                foulingFactor = Math.min(
                    params.maxFouling, 
                    params.foulingRate * Math.exp(4 * timeSinceFouling)
                );
            }
            simulationData.foulingValues.push(foulingFactor);
            
            // Randomly vary mass flows as described in the paper page 452:
            // "During the study the temperatures and massflows were allowed to vary randomly on certain intervals,
            // the hot temperatures were on the interval [54.7, 99.4]°C and the cold temperatures [13.3, 27.6]°C, 
            // the mass flow rates were on the interval [0.24, 1.7] kg/s."
            const mh = 0.24 + Math.random() * 1.46; // [0.24, 1.7] kg/s
            const mc = 0.24 + Math.random() * 1.46; // [0.24, 1.7] kg/s
            
            // Note: In a full implementation, we would also vary temperatures randomly
            // const Th_in = 54.7 + Math.random() * (99.4 - 54.7); // [54.7, 99.4]°C
            // const Tc_in = 13.3 + Math.random() * (27.6 - 13.3); // [13.3, 27.6]°C
            
            simulationData.mhValues.push(mh);
            simulationData.mcValues.push(mc);
            
            // Calculate U with the fouling factor using equation (31) from page 450:
            // U = 1/(1/(Ac*hc) + 1/(Ah*hh) + Rf)
            const U = calculateU(mh, mc, foulingFactor);
            simulationData.uValues.push(U);
            
            // Calculate U_ref for normalization
            const U_ref = calculateU(params.mh_ref, params.mc_ref, 0);
            
            // Store calculated F values for analysis
            // This would be used in a full implementation to track the correction factor's evolution
            // simulationData.fValues.push(F); // Uncommented in a full implementation
            
            // Calculate normalized parameters as per equations (22-23) on page 449:
            // "α(t) = α*·(mh_ref/mh(t))·(U(t)/U_ref)"
            // "β(t) = β*·(mc_ref/mc(t))·(U(t)/U_ref)"
            const normalized_alpha = params.alpha * (params.mh_ref / mh) * (U / U_ref);
            const normalized_beta = params.beta * (params.mc_ref / mc) * (U / U_ref);
            
            // Add noise to parameters - representing measurement noise in real systems
            // From page 449: "To compensate for deviations from the correct temperature values 
            // it is necessary to add a noise term, w(t), to the model"
            const noise1 = (Math.random() - 0.5) * 2 * params.noiseLevel;
            const noise2 = (Math.random() - 0.5) * 2 * params.noiseLevel;
            
            const noisy_alpha = normalized_alpha * (1 + noise1);
            const noisy_beta = normalized_beta * (1 + noise2);
            
            simulationData.alphaValues.push(noisy_alpha);
            simulationData.betaValues.push(noisy_beta);
            
            // Calculate CuSum for both parameters
            // Note: In a full implementation, the Kalman filter would be used as in the paper (page 449)
            // "During the parameter estimation the Kalman filter is used to estimate the states of the model."
            // For this web visualization, we focus on the parameter estimation and fouling detection.
            
            // From page 452: "Experiments showed that the model has problem to estimate
            // the τh and τc parameters correctly, this can also be seen from Table 1.
            // The reason for this is that the values of the τh and τc parameters that
            // minimize the score function are so small that the score function is
            // insensitive to the exact value of the parameters. To compensate for that
            // τh* and τc* in Eqs. (24) and (25) where kept constant at their calculated values."
            
            // Calculate moving average as specified in the paper page 451:
            // "When analyzing the parameters the average value of the parameters is calculated 
            // over a window of a specific length...the CuSum chart is used to monitor the average
            // value of the parameters for a shift from their reference value."
            const windowSize = 40;  // As specified in the paper
            let alphaAvg = 0;
            let betaAvg = 0;
            
            if (simulationData.alphaValues.length >= windowSize) {
                const recentAlphaValues = simulationData.alphaValues.slice(-windowSize);
                const recentBetaValues = simulationData.betaValues.slice(-windowSize);
                
                alphaAvg = recentAlphaValues.reduce((sum, val) => sum + val, 0) / windowSize;
                betaAvg = recentBetaValues.reduce((sum, val) => sum + val, 0) / windowSize;
            } else {
                alphaAvg = noisy_alpha;
                betaAvg = noisy_beta;
            }
            
            // CuSum calculation as defined in the paper page 451:
            // "a) Compute the cumulative sum: Cus(i) = max{0, x̄i - μ0 - K + Cus(i-1)}"
            // Since we're detecting a decrease in parameter values (α and β decrease with fouling),
            // we use (μ0 - x̄i) instead of (x̄i - μ0) as stated in the paper on page 450:
            // "In the case of fouling the parameters will decrease and it is therefore sufficient to do a one-sided test."
            // "If the process is under control the cumulative sum should fluctuate around the zero, if on the other hand there
            // is a shift in the value of the parameters the cumulative sum should shift either up- or downward depending on the shift"
            const alphaRef = params.alpha;  // Reference value (no fouling) - μ0
            const betaRef = params.beta;    // Reference value (no fouling) - μ0
            const lastCusumAlpha = simulationData.cusumAlpha[simulationData.cusumAlpha.length - 1];
            const lastCusumBeta = simulationData.cusumBeta[simulationData.cusumBeta.length - 1];
            
            // From page 451: "The parameters K and H were chosen to be 2σθ,clean and 3σθ,clean respectively"
            // K is the reference value set to 2σ
            const newCusumAlpha = Math.max(0, lastCusumAlpha + (alphaRef - alphaAvg - params.cusum_K));
            const newCusumBeta = Math.max(0, lastCusumBeta + (betaRef - betaAvg - params.cusum_K));
            
            simulationData.cusumAlpha.push(newCusumAlpha);
            simulationData.cusumBeta.push(newCusumBeta);
            
            // Check for fouling detection using criterion from page 451:
            // "b) If Cus(i) > H* then a drift is detected."
            // Where H* is the decision threshold set to 3σ
            if ((newCusumAlpha > params.cusum_H || newCusumBeta > params.cusum_H) && params.detectionTime === 0) {
                params.detectionTime = params.time;
                
                // Calculate dimensionless detection time as in Figure 4 on page 452:
                // "The dimensionless detection time on the y-axis can be compared to evolution of fouling in Figure 2."
                // This allows comparing results with those in the paper (where average detection time was ~0.77)
                const dimensionlessTime = (params.time - params.foulingStart) / 
                    (simulationData.timePoints.length - params.foulingStart);
                
                document.getElementById('detectionResult').innerHTML = 
                    '<p>Status: <strong>Fouling Detected!</strong></p>' +
                    `<p>Time since fouling start: ${params.time - params.foulingStart} time units</p>` +
                    `<p>Dimensionless detection time: ${dimensionlessTime.toFixed(2)}</p>` +
                    `<p>Fouling factor at detection: ${foulingFactor.toFixed(6)} m²·°C/W</p>` +
                    `<p>Parameter reduction: α: ${((1 - alphaAvg/params.alpha) * 100).toFixed(1)}%, β: ${((1 - betaAvg/params.beta) * 100).toFixed(1)}%</p>`;
            }
            
            // Update visualizations every 10 steps or when detection occurs
            if (params.time % 10 === 0 || params.detectionTime === params.time) {
                drawHeatExchanger();
                drawFoulingPlot();
                drawParameterPlot();
                drawDetectionPlot();
            }
            
            // Continue simulation
            if (params.running) {
                setTimeout(simulationStep, 200);
            }
        }
        
        let heatExchangerChart = null;
        
        function drawHeatExchanger() {
            const canvas = document.getElementById('heatExchangerCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get dimensions
            const width = canvas.width;
            const height = canvas.height;
            const gridSize = 4;
            
            // Get current mass flow values from simulation
            let mh = 1.0;
            let mc = 1.0;
            let foulingFactor = 0;
            
            if (simulationData.mhValues.length > 0) {
                mh = simulationData.mhValues[simulationData.mhValues.length - 1];
                mc = simulationData.mcValues[simulationData.mcValues.length - 1];
                foulingFactor = simulationData.foulingValues[simulationData.foulingValues.length - 1];
            }
            
            // Create a white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);
            
            // Define margins and sizes
            const topMargin = 30;
            const bottomMargin = 25;
            const sideMargin = 25;
            
            // Actual grid area
            const gridWidth = width - 2 * sideMargin;
            const gridHeight = height - topMargin - bottomMargin;
            
            // Cell dimensions
            const cellWidth = gridWidth / gridSize;
            const cellHeight = gridHeight / gridSize;
            
            // Calculate arrow thickness based on mass flow (between 2 and 6 for visibility)
            const hotArrowWidth = Math.max(2, Math.min(6, mh * 3));
            const coldArrowWidth = Math.max(2, Math.min(6, mc * 3));
            
            // Add title bar with fouling factor
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, topMargin);
            
            // Add top header with fouling factor
            ctx.fillStyle = '#8e44ad';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Fouling factor: ${foulingFactor.toFixed(6)} m²·°C/W`, width/2, topMargin-10);
            
            // Draw grid
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;
            
            // Draw vertical grid lines
            for (let i = 0; i <= gridSize; i++) {
                const x = sideMargin + i * cellWidth;
                ctx.beginPath();
                ctx.moveTo(x, topMargin);
                ctx.lineTo(x, height - bottomMargin);
                ctx.stroke();
            }
            
            // Draw horizontal grid lines
            for (let i = 0; i <= gridSize; i++) {
                const y = topMargin + i * cellHeight;
                ctx.beginPath();
                ctx.moveTo(sideMargin, y);
                ctx.lineTo(width - sideMargin, y);
                ctx.stroke();
            }
            
            // Draw outer border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.strokeRect(sideMargin, topMargin, gridWidth, gridHeight);
            
            // Add hot fluid label on top left
            ctx.textAlign = 'left';
            ctx.fillStyle = '#d35400';
            ctx.font = '12px Arial';
            ctx.fillText(`Hot fluid (ṁh = ${mh.toFixed(2)} kg/s)`, 10, 15);
            
            // Add cold fluid label on bottom right
            ctx.textAlign = 'right';
            ctx.fillStyle = '#3498db';
            ctx.fillText(`Cold fluid (ṁc = ${mc.toFixed(2)} kg/s)`, width - 10, height - 5);
            
            // Draw cold fluid flow (from left to right)
            ctx.fillStyle = '#3498db'; // Cold fluid color
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = coldArrowWidth;
            
            const arrowSize = 15;
            for (let i = 0; i < gridSize; i++) {
                const y = topMargin + (i + 0.5) * cellHeight;
                drawArrow(
                    ctx,
                    sideMargin + 5,
                    y,
                    width - sideMargin - 5,
                    y,
                    arrowSize,
                    coldArrowWidth
                );
            }
            
            // Draw hot fluid flow (from top to bottom)
            ctx.fillStyle = '#d35400'; // Hot fluid color
            ctx.strokeStyle = '#d35400';
            ctx.lineWidth = hotArrowWidth;
            
            for (let i = 0; i < gridSize; i++) {
                const x = sideMargin + (i + 0.5) * cellWidth;
                drawArrow(
                    ctx,
                    x,
                    topMargin + 5,
                    x,
                    height - bottomMargin - 5,
                    arrowSize,
                    hotArrowWidth
                );
            }
            
            // Show section labels
            ctx.font = '10px Arial';
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const cellX = sideMargin + i * cellWidth;
                    const cellY = topMargin + j * cellHeight;
                    
                    // Hot fluid labels - в верхнем левом углу ячейки
                    ctx.fillStyle = '#d35400';
                    ctx.textAlign = 'left';
                    ctx.fillText(`Th,${j+1}${i+1}`, cellX + 5, cellY + 15);
                    
                    // Cold fluid labels - в нижнем правом углу ячейки
                    ctx.fillStyle = '#3498db';
                    ctx.textAlign = 'right';
                    ctx.fillText(`Tc,${j+1}${i+1}`, cellX + cellWidth - 5, cellY + cellHeight - 5);
                }
            }
        }
        
        // Helper function to draw arrows
        function drawArrow(ctx, fromx, fromy, tox, toy, arrowSize, arrowWidth) {
            // Draw flow line
            ctx.beginPath();
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(tox, toy);
            ctx.stroke();
            
            // Calculate arrow head
            const angle = Math.atan2(toy - fromy, tox - fromx);
            
            // Draw arrow head
            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(
                tox - arrowSize * Math.cos(angle - Math.PI/6),
                toy - arrowSize * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                tox - arrowSize * Math.cos(angle) + arrowWidth * Math.cos(angle - Math.PI/2),
                toy - arrowSize * Math.sin(angle) + arrowWidth * Math.sin(angle - Math.PI/2)
            );
            ctx.lineTo(
                tox - arrowSize * Math.cos(angle + Math.PI/6),
                toy - arrowSize * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
        }
        
        let foulingChart = null;
        
        // Draw fouling evolution plot using Chart.js
        function drawFoulingPlot() {
            const ctx = document.getElementById('foulingChart').getContext('2d');
            
            // Prepare datasets
            const foulingData = [];
            for (let i = 0; i < simulationData.timePoints.length; i++) {
                foulingData.push({
                    x: simulationData.timePoints[i],
                    y: simulationData.foulingValues[i]
                });
            }
            
            // Create horizontal lines for reference values
            const typicalLow = 0.0001; // Lower limit of typical fouling factor
            const typicalHigh = 0.0004; // Upper limit shown in the simulation
            
            if (!foulingChart) {
                // Create chart if it doesn't exist
                foulingChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [
                            {
                                label: 'Fouling Factor',
                                data: foulingData,
                                borderColor: '#8e44ad',
                                backgroundColor: 'rgba(142, 68, 173, 0.1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                fill: false
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: {
                            duration: 0 // Отключаем анимацию для более плавного обновления
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: {
                                    display: true,
                                    text: 'Time'
                                }
                            },
                            y: {
                                min: 0,
                                max: params.maxFouling * 1.1,
                                title: {
                                    display: true,
                                    text: 'Fouling Factor R_f (m²·°C/W)'
                                }
                            }
                        },
                        plugins: {
                            annotation: {
                                annotations: {
                                    lowLine: {
                                        type: 'line',
                                        yMin: typicalLow,
                                        yMax: typicalLow,
                                        borderColor: '#27ae60',
                                        borderWidth: 1,
                                        borderDash: [5, 5],
                                        label: {
                                            content: `Typical lower design limit (${typicalLow})`,
                                            enabled: true,
                                            position: 'start'
                                        }
                                    },
                                    highLine: {
                                        type: 'line',
                                        yMin: typicalHigh,
                                        yMax: typicalHigh,
                                        borderColor: '#e74c3c',
                                        borderWidth: 1,
                                        borderDash: [5, 5],
                                        label: {
                                            content: `Maximum simulated fouling (${typicalHigh})`,
                                            enabled: true,
                                            position: 'end'
                                        }
                                    },
                                    foulingStart: params.foulingStart > 0 ? {
                                        type: 'line',
                                        xMin: params.foulingStart,
                                        xMax: params.foulingStart,
                                        borderColor: '#27ae60',
                                        borderWidth: 1,
                                        borderDash: [5, 5],
                                        label: {
                                            content: 'Fouling Start',
                                            enabled: true,
                                            position: 'top'
                                        }
                                    } : undefined
                                }
                            }
                        }
                    }
                });
            } else {
                // Update existing chart data
                foulingChart.data.datasets[0].data = foulingData;
                foulingChart.update('none'); // Update without animation for smoother performance
            }
        }
        
        let parameterChart = null;
        
        // Draw parameter plot using Chart.js
        function drawParameterPlot() {
            const ctx = document.getElementById('parameterChart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (parameterChart) {
                parameterChart.destroy();
            }
            
            // Prepare datasets for alpha and beta parameters
            const alphaData = [];
            const betaData = [];
            
            for (let i = 0; i < simulationData.timePoints.length; i++) {
                alphaData.push({
                    x: simulationData.timePoints[i],
                    y: simulationData.alphaValues[i]
                });
                
                betaData.push({
                    x: simulationData.timePoints[i],
                    y: simulationData.betaValues[i]
                });
            }
            
            parameterChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Alpha Parameter',
                            data: alphaData,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false
                        },
                        {
                            label: 'Beta Parameter',
                            data: betaData,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0 // Отключаем анимацию для более плавного обновления
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Parameter Value'
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                foulingStart: params.foulingStart > 0 ? {
                                    type: 'line',
                                    xMin: params.foulingStart,
                                    xMax: params.foulingStart,
                                    borderColor: '#27ae60',
                                    borderWidth: 1,
                                    borderDash: [5, 5],
                                    label: {
                                        content: 'Fouling Start',
                                        enabled: true,
                                        position: 'top'
                                    }
                                } : undefined
                            }
                        }
                    }
                }
            });
        }
        
        // Draw detection plot (CuSum)
        let detectionChart = null;
        
        function drawDetectionPlot() {
            const ctx = document.getElementById('detectionChart').getContext('2d');
            
            // Destroy previous chart if it exists
            if (detectionChart) {
                detectionChart.destroy();
            }
            
            // Prepare datasets for CuSum alpha and beta
            const cusumAlphaData = [];
            const cusumBetaData = [];
            
            for (let i = 0; i < simulationData.timePoints.length; i++) {
                cusumAlphaData.push({
                    x: simulationData.timePoints[i],
                    y: simulationData.cusumAlpha[i]
                });
                
                cusumBetaData.push({
                    x: simulationData.timePoints[i],
                    y: simulationData.cusumBeta[i]
                });
            }
            
            // Find maximum CuSum value for scaling
            let maxCusum = Math.max(params.cusum_H * 1.5, 0.02); // Minimum value to show
            for (let i = 0; i < simulationData.cusumAlpha.length; i++) {
                maxCusum = Math.max(maxCusum, simulationData.cusumAlpha[i], simulationData.cusumBeta[i]);
            }
            
            // Build annotations object
            const annotations = {
                threshold: {
                    type: 'line',
                    yMin: params.cusum_H,
                    yMax: params.cusum_H,
                    borderColor: '#e67e22',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    label: {
                        content: `Threshold (H* = ${params.cusum_H})`,
                        enabled: true,
                        position: 'start'
                    }
                },
                foulingStart: params.foulingStart > 0 ? {
                    type: 'line',
                    xMin: params.foulingStart,
                    xMax: params.foulingStart,
                    borderColor: '#27ae60',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    label: {
                        content: 'Fouling Start',
                        enabled: true,
                        position: 'top'
                    }
                } : undefined
            };
            
            // Add detection time line if detected
            if (params.detectionTime > 0) {
                annotations.detection = {
                    type: 'line',
                    xMin: params.detectionTime,
                    xMax: params.detectionTime,
                    borderColor: '#8e44ad',
                    borderWidth: 1,
                    borderDash: [2, 2],
                    label: {
                        content: 'Detection',
                        enabled: true,
                        position: 'top'
                    }
                };
            }
            
            detectionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'CuSum α',
                            data: cusumAlphaData,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false
                        },
                        {
                            label: 'CuSum β',
                            data: cusumBetaData,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0 // Отключаем анимацию для более плавного обновления
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            min: 0,
                            max: maxCusum * 1.1,
                            title: {
                                display: true,
                                text: 'CuSum Value'
                            }
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: annotations
                        }
                    }
                }
            });
        }
        
        // Event listeners
        document.getElementById('startButton').addEventListener('click', function() {
            if (!params.running) {
                params.running = true;
                this.textContent = 'Pause Simulation';
                simulationStep();
            } else {
                params.running = false;
                this.textContent = 'Start Simulation';
            }
        });
        
        document.getElementById('resetButton').addEventListener('click', function() {
            params.running = false;
            document.getElementById('startButton').textContent = 'Start Simulation';
            initSimulation();
        });
        
        document.getElementById('foulingRate').addEventListener('input', function() {
            const value = this.value / 100 * 0.0005;
            params.foulingRate = value;
            document.getElementById('foulingRateValue').textContent = value.toFixed(5);
        });
        
        document.getElementById('noiseLevel').addEventListener('input', function() {
            const value = this.value / 100 * 0.02;
            params.noiseLevel = value;
            document.getElementById('noiseLevelValue').textContent = (value * 100).toFixed(1) + '%';
        });
        
        // Initialize on load
        window.addEventListener('load', initSimulation);
    </script>
</body>
</html>